// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AssetData.proto

#ifndef PROTOBUF_AssetData_2eproto__INCLUDED
#define PROTOBUF_AssetData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tigeropen {
namespace push {
namespace pb {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_AssetData_2eproto();
void protobuf_InitDefaults_AssetData_2eproto();
void protobuf_AssignDesc_AssetData_2eproto();
void protobuf_ShutdownFile_AssetData_2eproto();

class AssetData;

// ===================================================================

class AssetData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tigeropen.push.pb.AssetData) */ {
 public:
  AssetData();
  virtual ~AssetData();

  AssetData(const AssetData& from);

  inline AssetData& operator=(const AssetData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetData& default_instance();

  static const AssetData* internal_default_instance();

  void Swap(AssetData* other);

  // implements Message ----------------------------------------------

  inline AssetData* New() const { return New(NULL); }

  AssetData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetData& from);
  void MergeFrom(const AssetData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetData* other);
  void UnsafeMergeFrom(const AssetData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // optional string currency = 2;
  void clear_currency();
  static const int kCurrencyFieldNumber = 2;
  const ::std::string& currency() const;
  void set_currency(const ::std::string& value);
  void set_currency(const char* value);
  void set_currency(const char* value, size_t size);
  ::std::string* mutable_currency();
  ::std::string* release_currency();
  void set_allocated_currency(::std::string* currency);

  // optional string segType = 3;
  void clear_segtype();
  static const int kSegTypeFieldNumber = 3;
  const ::std::string& segtype() const;
  void set_segtype(const ::std::string& value);
  void set_segtype(const char* value);
  void set_segtype(const char* value, size_t size);
  ::std::string* mutable_segtype();
  ::std::string* release_segtype();
  void set_allocated_segtype(::std::string* segtype);

  // optional double availableFunds = 4;
  void clear_availablefunds();
  static const int kAvailableFundsFieldNumber = 4;
  double availablefunds() const;
  void set_availablefunds(double value);

  // optional double excessLiquidity = 5;
  void clear_excessliquidity();
  static const int kExcessLiquidityFieldNumber = 5;
  double excessliquidity() const;
  void set_excessliquidity(double value);

  // optional double netLiquidation = 6;
  void clear_netliquidation();
  static const int kNetLiquidationFieldNumber = 6;
  double netliquidation() const;
  void set_netliquidation(double value);

  // optional double equityWithLoan = 7;
  void clear_equitywithloan();
  static const int kEquityWithLoanFieldNumber = 7;
  double equitywithloan() const;
  void set_equitywithloan(double value);

  // optional double buyingPower = 8;
  void clear_buyingpower();
  static const int kBuyingPowerFieldNumber = 8;
  double buyingpower() const;
  void set_buyingpower(double value);

  // optional double cashBalance = 9;
  void clear_cashbalance();
  static const int kCashBalanceFieldNumber = 9;
  double cashbalance() const;
  void set_cashbalance(double value);

  // optional double grossPositionValue = 10;
  void clear_grosspositionvalue();
  static const int kGrossPositionValueFieldNumber = 10;
  double grosspositionvalue() const;
  void set_grosspositionvalue(double value);

  // optional double initMarginReq = 11;
  void clear_initmarginreq();
  static const int kInitMarginReqFieldNumber = 11;
  double initmarginreq() const;
  void set_initmarginreq(double value);

  // optional double maintMarginReq = 12;
  void clear_maintmarginreq();
  static const int kMaintMarginReqFieldNumber = 12;
  double maintmarginreq() const;
  void set_maintmarginreq(double value);

  // optional uint64 timestamp = 13;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 13;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tigeropen.push.pb.AssetData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr currency_;
  ::google::protobuf::internal::ArenaStringPtr segtype_;
  double availablefunds_;
  double excessliquidity_;
  double netliquidation_;
  double equitywithloan_;
  double buyingpower_;
  double cashbalance_;
  double grosspositionvalue_;
  double initmarginreq_;
  double maintmarginreq_;
  ::google::protobuf::uint64 timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_AssetData_2eproto_impl();
  friend void  protobuf_AddDesc_AssetData_2eproto_impl();
  friend void protobuf_AssignDesc_AssetData_2eproto();
  friend void protobuf_ShutdownFile_AssetData_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AssetData> AssetData_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AssetData

// optional string account = 1;
inline void AssetData::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetData::account() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.account)
  return account_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.account)
}
inline void AssetData::set_account(const char* value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tigeropen.push.pb.AssetData.account)
}
inline void AssetData::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tigeropen.push.pb.AssetData.account)
}
inline ::std::string* AssetData::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:tigeropen.push.pb.AssetData.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetData::release_account() {
  // @@protoc_insertion_point(field_release:tigeropen.push.pb.AssetData.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:tigeropen.push.pb.AssetData.account)
}

// optional string currency = 2;
inline void AssetData::clear_currency() {
  currency_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetData::currency() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.currency)
  return currency_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_currency(const ::std::string& value) {
  
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.currency)
}
inline void AssetData::set_currency(const char* value) {
  
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tigeropen.push.pb.AssetData.currency)
}
inline void AssetData::set_currency(const char* value, size_t size) {
  
  currency_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tigeropen.push.pb.AssetData.currency)
}
inline ::std::string* AssetData::mutable_currency() {
  
  // @@protoc_insertion_point(field_mutable:tigeropen.push.pb.AssetData.currency)
  return currency_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetData::release_currency() {
  // @@protoc_insertion_point(field_release:tigeropen.push.pb.AssetData.currency)
  
  return currency_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_allocated_currency(::std::string* currency) {
  if (currency != NULL) {
    
  } else {
    
  }
  currency_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currency);
  // @@protoc_insertion_point(field_set_allocated:tigeropen.push.pb.AssetData.currency)
}

// optional string segType = 3;
inline void AssetData::clear_segtype() {
  segtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetData::segtype() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.segType)
  return segtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_segtype(const ::std::string& value) {
  
  segtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.segType)
}
inline void AssetData::set_segtype(const char* value) {
  
  segtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tigeropen.push.pb.AssetData.segType)
}
inline void AssetData::set_segtype(const char* value, size_t size) {
  
  segtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tigeropen.push.pb.AssetData.segType)
}
inline ::std::string* AssetData::mutable_segtype() {
  
  // @@protoc_insertion_point(field_mutable:tigeropen.push.pb.AssetData.segType)
  return segtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetData::release_segtype() {
  // @@protoc_insertion_point(field_release:tigeropen.push.pb.AssetData.segType)
  
  return segtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetData::set_allocated_segtype(::std::string* segtype) {
  if (segtype != NULL) {
    
  } else {
    
  }
  segtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), segtype);
  // @@protoc_insertion_point(field_set_allocated:tigeropen.push.pb.AssetData.segType)
}

// optional double availableFunds = 4;
inline void AssetData::clear_availablefunds() {
  availablefunds_ = 0;
}
inline double AssetData::availablefunds() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.availableFunds)
  return availablefunds_;
}
inline void AssetData::set_availablefunds(double value) {
  
  availablefunds_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.availableFunds)
}

// optional double excessLiquidity = 5;
inline void AssetData::clear_excessliquidity() {
  excessliquidity_ = 0;
}
inline double AssetData::excessliquidity() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.excessLiquidity)
  return excessliquidity_;
}
inline void AssetData::set_excessliquidity(double value) {
  
  excessliquidity_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.excessLiquidity)
}

// optional double netLiquidation = 6;
inline void AssetData::clear_netliquidation() {
  netliquidation_ = 0;
}
inline double AssetData::netliquidation() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.netLiquidation)
  return netliquidation_;
}
inline void AssetData::set_netliquidation(double value) {
  
  netliquidation_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.netLiquidation)
}

// optional double equityWithLoan = 7;
inline void AssetData::clear_equitywithloan() {
  equitywithloan_ = 0;
}
inline double AssetData::equitywithloan() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.equityWithLoan)
  return equitywithloan_;
}
inline void AssetData::set_equitywithloan(double value) {
  
  equitywithloan_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.equityWithLoan)
}

// optional double buyingPower = 8;
inline void AssetData::clear_buyingpower() {
  buyingpower_ = 0;
}
inline double AssetData::buyingpower() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.buyingPower)
  return buyingpower_;
}
inline void AssetData::set_buyingpower(double value) {
  
  buyingpower_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.buyingPower)
}

// optional double cashBalance = 9;
inline void AssetData::clear_cashbalance() {
  cashbalance_ = 0;
}
inline double AssetData::cashbalance() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.cashBalance)
  return cashbalance_;
}
inline void AssetData::set_cashbalance(double value) {
  
  cashbalance_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.cashBalance)
}

// optional double grossPositionValue = 10;
inline void AssetData::clear_grosspositionvalue() {
  grosspositionvalue_ = 0;
}
inline double AssetData::grosspositionvalue() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.grossPositionValue)
  return grosspositionvalue_;
}
inline void AssetData::set_grosspositionvalue(double value) {
  
  grosspositionvalue_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.grossPositionValue)
}

// optional double initMarginReq = 11;
inline void AssetData::clear_initmarginreq() {
  initmarginreq_ = 0;
}
inline double AssetData::initmarginreq() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.initMarginReq)
  return initmarginreq_;
}
inline void AssetData::set_initmarginreq(double value) {
  
  initmarginreq_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.initMarginReq)
}

// optional double maintMarginReq = 12;
inline void AssetData::clear_maintmarginreq() {
  maintmarginreq_ = 0;
}
inline double AssetData::maintmarginreq() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.maintMarginReq)
  return maintmarginreq_;
}
inline void AssetData::set_maintmarginreq(double value) {
  
  maintmarginreq_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.maintMarginReq)
}

// optional uint64 timestamp = 13;
inline void AssetData::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetData::timestamp() const {
  // @@protoc_insertion_point(field_get:tigeropen.push.pb.AssetData.timestamp)
  return timestamp_;
}
inline void AssetData::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:tigeropen.push.pb.AssetData.timestamp)
}

inline const AssetData* AssetData::internal_default_instance() {
  return &AssetData_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace push
}  // namespace tigeropen

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AssetData_2eproto__INCLUDED
